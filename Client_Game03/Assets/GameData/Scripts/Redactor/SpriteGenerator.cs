#if UNITY_EDITOR
using General;
using System;
using System.IO;
using UnityEditor;
using UnityEditor.AddressableAssets;
using UnityEditor.AddressableAssets.Settings;
using UnityEngine;

namespace Assets.GameData.Scripts.Redactor
{

    /// <summary>
    /// Предоставляет функционал для создания и кеширования двух спрайтов с разными настройками из одного исходного изображения.
    /// </summary>
    public static class SpriteGenerator
    {
        /// <summary> Целевой размер для маленького спрайта. </summary>
        private const int TARGET_SMALL_SIZE = 128;
        private const string START_DIR = "Assets/GameData/AddressableAssets/Images";
        private const string GROUP_NAME_GENERATED_SPRITES = "Generated Sprites";
        private static readonly string START_DIR_SMALL_SIZE = $"{START_DIR}_{TARGET_SMALL_SIZE}_AutoGenerated";
        public const string EQUIPMENT_PREFIX_SMALL = "-(small)";

        /// <summary>
        /// Добавляет пункт в верхнее меню Unity
        /// </summary>
        //[MenuItem("_Game03/Генерировать спрайты 128x128")]
        private static void CreateSprites()
        {
            if (string.Empty == "")
            {
                return;
            }
            string[] files = Directory.GetFiles(START_DIR, "*.*", SearchOption.AllDirectories);
            for (int i = 0; i < files.Length; i++)
            {
                files[i] = files[i].ToLowerInvariant().ToDirectSlash();
            }

            string[] whiteList = { PathGame03.Combine(START_DIR, "equipment").ToLowerInvariant() };
            string[] formats = { ".jpg", ".png" };

            foreach (string file in files)
            {
                bool cont = true;
                foreach (string wl in whiteList)
                {
                    if (file.StartsWith(wl))
                    {
                        cont = false;
                        break;
                    }
                }
                if (cont)
                {
                    continue;
                }

                cont = true;
                foreach (string bl in formats)
                {
                    if (file.EndsWith(bl))
                    {
                        cont = false;
                        break;
                    }
                }
                if (cont)
                {
                    continue;
                }


                // Получаем путь относительно START_DIR
                string relativePath = file[(START_DIR.Length + 1)..];
                CreateDualSprites(relativePath, EQUIPMENT_PREFIX_SMALL);
            }

            //CreateDualSprites("Equipment/_Unique/thunderfury.jpg", EQUIPMENT_PREFIX_SMALL);

            // Выводим уведомление в центре экрана редактора
            _ = EditorUtility.DisplayDialog(nameof(SpriteGenerator), "Генерация спрайтов успешно завершена!", "OK");
        }


        private static void CreateDualSprites(string assetPathInput, string suffix)
        {
            string assetPath = PathGame03.Combine(START_DIR, assetPathInput).ToDirectSlash();

            if (!File.Exists(assetPath))
            {
                throw new ArgumentException($"Файл {assetPath} не найден.");
            }

            string extensionFile = Path.GetExtension(assetPath);
            if (!extensionFile.IsEmpty() && extensionFile.Length < assetPathInput.Length && extensionFile.ToLower() == ".jpg")
            {
                assetPathInput = assetPathInput[..^extensionFile.Length];
            }

            string smallAssetPath = PathGame03.Combine(START_DIR_SMALL_SIZE, $"{assetPathInput}.png").ToDirectSlash();
            string smallAssetPathDir = Path.GetDirectoryName(smallAssetPath);
            if (!Directory.Exists(smallAssetPathDir))
            {
                _ = Directory.CreateDirectory(smallAssetPathDir);
            }

            // 1. Настраиваем оригинал. ВАЖНО: Включаем MipMaps и Read/Write
            ConfigureLargeImporterIfChanged(assetPath);

            // 2. Создаем малую версию, используя качественные мип-мапы оригинала
            if (!File.Exists(smallAssetPath))
            {
                // Оборачиваем в try-catch, чтобы гарантировать возврат настроек импортера в случае ошибки
                try
                {
                    CreateHighQualitySmallVersion(assetPath, smallAssetPath, TARGET_SMALL_SIZE);
                }
                catch (Exception e)
                {
                    Debug.LogError($"Ошибка при создании малого спрайта: {e.Message}");
                    // Важно: если что-то пошло не так, убедимся, что оригинал остался в нужном состоянии
                    ConfigureLargeImporterIfChanged(assetPath);
                    throw;
                }
            }

            // 3. Регистрация в Addressables (код прежний)
            string assetAddressableName = assetPathInput.Replace('/', '-').Replace("_", "").ToLower();
            AddressableNamesGenerator.RegisterInAddressables(assetPath, assetAddressableName, GROUP_NAME_GENERATED_SPRITES);
            AddressableNamesGenerator.RegisterInAddressables(smallAssetPath, assetAddressableName + suffix, GROUP_NAME_GENERATED_SPRITES);

            AssetDatabase.SaveAssets();
        }

        private static void ConfigureLargeImporterIfChanged(string path)
        {
            var importer = AssetImporter.GetAtPath(path) as TextureImporter;
            if (importer == null)
            {
                return;
            }

            // Проверяем все критичные настройки
            bool needsReimport = importer.textureType != TextureImporterType.Sprite ||
                                 importer.maxTextureSize != 1024 ||
                                 importer.textureCompression != TextureImporterCompression.CompressedHQ ||
                                 !importer.isReadable || // Обязательно для чтения пикселей
                                 !importer.mipmapEnabled; // Обязательно для качественного даунскейла

            if (needsReimport)
            {
                importer.textureType = TextureImporterType.Sprite;
                importer.maxTextureSize = 1024;
                importer.textureCompression = TextureImporterCompression.CompressedHQ;

                // Критически важные настройки для нового метода
                importer.isReadable = true;
                importer.mipmapEnabled = true;

                importer.SaveAndReimport();
            }
        }

        /// <summary>
        /// Извлекает конкретный уровень мип-мапа из исходной текстуры для получения изображения высокого качества.
        /// </summary>
        private static void CreateHighQualitySmallVersion(string sourcePath, string targetPath, int targetSize)
        {
            Texture2D sourceTexture = AssetDatabase.LoadAssetAtPath<Texture2D>(sourcePath);
            if (sourceTexture == null)
            {
                throw new IOException($"Не удалось загрузить текстуру {sourcePath}");
            }

            int maxDimension = Mathf.Max(sourceTexture.width, sourceTexture.height);

            // Проверка: если исходник уже меньше или равен целевому размеру
            if (maxDimension <= targetSize)
            {
                Debug.LogWarning($"Исходное изображение {sourceTexture.name} меньше или равно {targetSize}px. Качество может пострадать.");
                // В крайнем случае используем старый метод, но это редкий кейс
                CreateSmallVersionBlitFallback(sourceTexture, targetPath, targetSize);
                return;
            }

            // Вычисляем нужный уровень мип-мапа.
            // Например, 1024 -> 128. Log2(1024/128) = Log2(8) = 3.
            // Уровень 0 = 1024, Ур 1 = 512, Ур 2 = 256, Ур 3 = 128.
            int mipLevel = Mathf.RoundToInt(Mathf.Log(maxDimension / (float)targetSize, 2));

            // Проверяем, есть ли такой уровень
            if (mipLevel >= sourceTexture.mipmapCount)
            {
                // Если мип-мапов не хватило (странно, но бывает), фоллбэк на Blit
                Debug.LogWarning("Не найден подходящий уровень MIP-map. Используется fallback метод (качество ниже).");
                CreateSmallVersionBlitFallback(sourceTexture, targetPath, targetSize);
                return;
            }

            // Вычисляем размеры целевого уровня
            int targetWidth = Mathf.Max(1, sourceTexture.width >> mipLevel);
            int targetHeight = Mathf.Max(1, sourceTexture.height >> mipLevel);

            // Создаем новую текстуру нужного размера
            var smallTexture = new Texture2D(targetWidth, targetHeight, TextureFormat.RGBA32, false);

            // Считываем пиксели напрямую из качественного мип-мапа
            Color[] highQualityPixels = sourceTexture.GetPixels(mipLevel);
            smallTexture.SetPixels(highQualityPixels);
            smallTexture.Apply(false); // false = мипмапы для маленькой не нужны

            // Сохранение и импорт (код прежний)
            SaveAndImportSmallTexture(smallTexture, targetPath, targetSize);
        }

        // Вспомогательный метод для сохранения PNG и настройки импортера
        private static void SaveAndImportSmallTexture(Texture2D texture, string targetPath, int maxSize)
        {
            File.WriteAllBytes(targetPath, texture.EncodeToPNG());
            // Удаляем текстуру из памяти
            UnityEngine.Object.DestroyImmediate(texture);

            AssetDatabase.ImportAsset(targetPath);

            var importer = AssetImporter.GetAtPath(targetPath) as TextureImporter;
            if (importer != null)
            {
                importer.textureType = TextureImporterType.Sprite;
                importer.maxTextureSize = maxSize;
                importer.textureCompression = TextureImporterCompression.Uncompressed;
                importer.mipmapEnabled = false; // Маленькому спрайту мипы обычно не нужны
                importer.SaveAndReimport();
            }
        }

        // Старый метод на случай, если с мип-мапами что-то пойдет не так
        private static void CreateSmallVersionBlitFallback(Texture2D sourceTexture, string targetPath, int targetSize)
        {
            var rt = RenderTexture.GetTemporary(targetSize, targetSize);
            Graphics.Blit(sourceTexture, rt);
            RenderTexture.active = rt;
            var smallTexture = new Texture2D(targetSize, targetSize, TextureFormat.RGBA32, false);
            smallTexture.ReadPixels(new Rect(0, 0, targetSize, targetSize), 0, 0);
            smallTexture.Apply();
            RenderTexture.active = null;
            RenderTexture.ReleaseTemporary(rt);

            SaveAndImportSmallTexture(smallTexture, targetPath, targetSize);
        }

        /// <summary>
        /// Регистрирует ассет в указанной группе Addressables.
        /// </summary>
        /// <param name="guid">GUID ассета.</param>
        /// <param name="address">Адрес, который будет назначен ассету.</param>
        /// <param name="groupName">Имя целевой группы.</param>
        /// <exception cref="ArgumentNullException">Генерируется, если guid или groupName равны null.</exception>
        public static void RegisterInGroup(string guid, string address, string groupName)
        {
            AddressableAssetSettings settings = AddressableAssetSettingsDefaultObject.Settings;

            // Получаем или создаем группу
            AddressableAssetGroup group = GetOrCreateGroup(settings, groupName);

            // Перемещаем или создаем запись в конкретной группе
            AddressableAssetEntry entry = settings.CreateOrMoveEntry(guid, group);

            if (entry != null)
            {
                entry.address = address;
            }
        }

        /// <summary>
        /// Возвращает существующую группу Addressables или создает новую с настройками по умолчанию.
        /// </summary>
        /// <param name="settings">Текущие настройки Addressables.</param>
        /// <param name="groupName">Имя группы.</param>
        /// <returns>Объект группы <see cref="AddressableAssetGroup"/>.</returns>
        private static AddressableAssetGroup GetOrCreateGroup(AddressableAssetSettings settings, string groupName)
        {
            if (string.IsNullOrWhiteSpace(groupName))
            {
                throw new ArgumentException("Имя группы не может быть пустым.", nameof(groupName));
            }

            AddressableAssetGroup group = settings.FindGroup(groupName);

            if (group == null)
            {
                // Создаем новую группу, копируя схемы из стандартной группы (например, BundledAssetGroupSchema)
                group = settings.CreateGroup(groupName, false, false, true, settings.DefaultGroup.Schemas);
            }

            return group;
        }
    }
}
#endif
